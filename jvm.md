# JVM
## JVM이란
>JVM이란, 자바 가상 머신의 약자를 줄여 부르는 용어이다.
 일반적인 프로그램은 Windows또는 Linux같은 OS 위에서 실행된다. 하지만 자바 프로그램 같은 경우에는 OS 위의 JVM에서 실행이된다. 이렇게 JVM위에서 굳이 자바 프로그램을 돌리는 이유는 자바 프로그램을 OS에 상관없이 실행시키기 위함이다. 예를들어 Windows에서 동작하도록 구현된 워드 프로그램은 Linux에서 동작하지 않는다. 이 워드 프로그램을 Mac환경에서 돌리기 위해서는 Mac기반으로 다시 구현해야 한다. 하지만 자바 프로그램 같은 경우 어떤 OS 에서도 그에 맞는 JVM 다운로드를 통해 자바 프로그램을 실행 실킬 수 있다.

 ## JVM의 역활
   - 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행한다.
   - JVM은 자바와 OS사이에서 중개자 역할을 수행하여 OS에 독립적인 플랫폼을 갖게 해준다. 
   - JVM은 프로그램의 메모리 관리를 알아서 해준다. C프로그램 같은 경우에는 직접 메모리 할당을 해주고 해지해줘야한다. 하지만 자바에서는 JVM이 자동으로 메모리 관리를 해주는 장점이 있다.

## JVM의 중요성
당장 jvm이 왜 중요한지 와닿지 않을수도 있다. jvm이 메모리도 관리해 주는데 왜 jvm을 더 깊게 알아야 하는 것일까? 그 이유는 메모리관리가 효율성과 관련이 있고 이는 곧 어플리케이션의 성능과 직접적인 연결이 되기 때문이다. 현 사용자들은 속도에 매우 민감하고 느린 어플리케이션을 사용하지 않을 것이다.

## JVM의 실행과정
  1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다. JVM은 이 메모리를 용도에 맞게 여러 영역으로 나누어 관리한다.
1. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
1. 클래스 로더를 통해 class 파일들을 JVM으로 로딩한다.
1. 로딩된 class 파일들은 Execution engine을 통해 해석된다.
1. 해석된 바이트코드(.class)는 Runtime Data Areas에 배치되고 수행이 이루어지게 된다. 이러한 과정속에서 JVM은 필요에 따라 GC 같은 관리 작업을 수행한다.
![jvm](https://user-images.githubusercontent.com/87690768/134809454-0d7cf372-49a8-41a5-ade8-a2132f8d2b89.png)

## JVM 구성 설명
### Java Compiler(컴파일러)
- 자바 소스(.java)코드를 Byte code(.class)로 변환하는 역할

### Class Loader
- 자바 바이트 코드를 읽어서 JVM의 Execution Engine이 사용할 수 있도록 Runtime Data Area에 적재하는 역할

### Execution Engine(실행 엔진)
- 클래스를 실행시키는 역할
- 실행 엔진은 메모리에 적재된 바이트 코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경
> 실행엔진의 두 가지 방식 <br>
> - nterpreter<br>
> 명령어를 그때그때 해석해서 실행하게 되어 있다.
>
> - JIT(Just-In-Time)<br>
> 인터프리터의 단점을 보완하기 위해 도입된 컴파일러이다. 인터프리터 방식으로 실행하다가 적절한 시점에서 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행하게 된다.
### Runtime Data Areas
- 런타임 데이터 영역은 프로그램을 수행하기 위해 OS에서 할당받는 메모리 영역
-  런타임 데이터 영역은 5개의 영역으로 나눔
-   이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area) 은 모든 스레드가 공유해서 사용

<img width="589" alt="스크린샷 2021-09-26 오후 10 10 15" src="https://user-images.githubusercontent.com/87690768/134809485-fb8d2847-f8cc-438a-a94c-7d1e95d7bdfa.png">

### PC Register
- 스레드가 시작될 때 생성
-  PC레지스터는 Thread가 어떤 명령어로 실행되어야 할지에 대한 기록을 하는 부분으로 현재 수행중인 JVM명령의 주소를 갖음

### Stack Area
- 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역
-  지역변수, 매개변수, 메소드 정보, 연산 중 발생하는 임시 데이터등 저장
-   메소드 호출 시마다 각각의 스택 프레임(그 메소드만을 위한 공간)이 생성된다. 메서드 수행이 끝나면 프레임 별로 삭제

### Native method stack
- 일반적으로 JVM은 네이티브 방식을 지원
- 따라서 스레드에서 네이티브 방식의 메소드가 실행되는 경우 Native Method Stack에 쌓임
- 일반적인 메소드를 실행하는 경우 JVM 스택에 쌓이다가 해당 메소드 내부에 네이티브 방식을 사용하는 메소드(예를 들면 C언어로 작성된 메소드)가 있다면 해당 메소드는 네이티브 스택에 쌓임

### Heap Area
- 동적으로 할당되는 데이터가 저장되는 영역
- 예를들어 객체생, 배열등이 생성되었을 때 저장되는 공간
- Heap에 할당된 데이터는 GC의 대상 
- JVM 성능 등의 이슈에서 가장 많이 언급되는 공간 

### Method Area(Class Area, Code Area, Static Area)
- 메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성
-  JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 코드, Static 변수, 메서드의 바이트코드 등을 보관

### Runtime constant pool
- Method area 내부에 존재하는 영역으로, 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블
-  즉, 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행
  
***참조*** [HANUL](https://hanul-dev.netlify.app/java/%EC%9E%90%EB%B0%94%EA%B0%80%EB%A8%B8%EC%8B%A0(jvm)%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/#java-compiler)

